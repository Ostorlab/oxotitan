<template>
  <div>
    <VulnerabilityTitle
      :title="title"
      :risk-rating="highestRiskRating"
      :loading="loading"
    />
    <DfMaterialCard
      color="grey darken-1"
      light
      max-width="100%"
      class="my-12"
      icon="mdi-bug-outline"
      title="Description"
    >
      <DfEnhancedMdRender :content="description" />
    </DfMaterialCard>
    <DfMaterialCard
      color="green lighten-1"
      light
      max-width="100%"
      class="my-12"
      icon="mdi-wrench-outline"
      title="Recommendation"
    >
      <DfEnhancedMdRender :content="recommendation" />
    </DfMaterialCard>
    <DfMaterialCard
      v-if="references !== null"
      color="blue lighten-1"
      light
      max-width="100%"
      class="my-12"
      icon="mdi-link"
      title="References"
    >
      <ul>
        <li
          v-for="(url, referenceTitle) in references"
          :key="referenceTitle"
        >
          <a
            :href="url"
            target="_blank"
          >{{ referenceTitle }}</a>
        </li>
      </ul>
    </DfMaterialCard>
    <DfMaterialCard
      color="red lighten-1"
      light
      max-width="100%"
      class="my-12"
      icon="mdi-code-braces"
      title="Technical Details"
    >
      <template #title-extra-info>
        <p class="pa-0 ma-0 mr-1 grey--text">
          Has {{ vulnerabilitiesCountText }}
        </p>
      </template>
      <template
        v-for="(item, i) of vulnz"
        :key="`issue-${item.id}-${i}`"
      >
        <div class="title d-flex align-center">
          <p class="mb-0">
            Issue #{{ i + 1 }}
          </p>
        </div>
        <DfEnhancedMdRender :content="item.content" />
        <v-divider
          v-if="i !== vulnz.length - 1"
          :key="i"
          class="mt-7 mb-4"
        />
      </template>
    </DfMaterialCard>
  </div>
</template>

<script lang="ts">
import { Mutex } from 'async-mutex'
import VulnerabilityService from '~/scan/services/vulnerability.service'
import VulnerabilityTitle from '~/scan/components/vulnz/VulnerabilityTitle.vue'
import { DfMaterialCard } from '~/dragonfly/components/Cards/DfMaterialCard'
import { DfEnhancedMdRender } from '~/dragonfly/components/Sections/DfMdRender'
import { type Maybe, type OxoVulnerabilityType, type RiskRatingEnum } from '~/graphql/types'

interface Data {
  vulnerabilityService: VulnerabilityService
  getVulnInfo: boolean
  mutex: Mutex
  loading: boolean
  references: { [key: string]: string }
  vulnz: Array<OxoVulnerabilityType>
  itemsPerPage: number
  currentPage: number
  countVulnerabilities: number
  highestRiskRating?: Maybe<RiskRatingEnum>
  title?: Maybe<string>
  description?: Maybe<string>
  recommendation?: Maybe<string>
}

// TODO (Rabson) Read the scanner from the object passed from the scan page.
const SCANNER = {
  name: 'dummy',
  endpoint: 'http://127.0.0.1:3420/graphql',
  apiKey: '8393daf3-5e8c-4cd8-b030-25fd89505ff2'
}

export default defineComponent({
  name: 'VulnerabilityDetail',
  components: { VulnerabilityTitle, DfMaterialCard, DfEnhancedMdRender },
  props: {
    scanId: {
      type: [Number, String],
      required: true
    },
    vulnTitle: {
      type: String,
      required: true
    }
  },
  data(): Data {
    return {
      loading: true,
      vulnerabilityService: new VulnerabilityService(this.$axios),
      mutex: new Mutex(),
      getVulnInfo: true,
      references: {},
      vulnz: [],
      itemsPerPage: 10,
      currentPage: 1,
      countVulnerabilities: 0,
      highestRiskRating: null,
      title: null,
      description: null,
      recommendation: null
    }
  },
  computed: {
    /**
     * The text to show (issue or issues) depending on the number of vulnerabilities.
     */
    vulnerabilitiesCountText(): string {
      if (this.countVulnerabilities === 0 || this.countVulnerabilities > 1) {
        return `${this.countVulnerabilities} issues`
      }
      return `${this.countVulnerabilities} issue`
    }
  },
  watch: {
    async vulnTitle() {
      this.getVulnInfo = true
      this.vulnz = []
      this.references = {}
      await this.fetchData()
    }
  },
  async created() {
    await this.fetchData()
  },
  methods: {
    /**
     * Fetch vulenrability data.
     */
    async fetchData(): Promise<void> {
      this.vulnerabilityService = new VulnerabilityService(this.$axios)
      await this.getDataFromApi()
    },
    /**
     * Get vulernerability data.
     */
    async getDataFromApi(): Promise<void> {
      const release = await this.mutex.acquire()
      try {
        if (this.vulnerabilityService.hasNext === true) {
          this.loading = true
          if (this.getVulnInfo === true) {
            const kbVulnerabilities = await this.vulnerabilityService.getVulnerabilitiesWithInfo({
              scanner: SCANNER,
              scanId: parseInt(this.scanId as string),
              vulnDetailTitles: [this.vulnTitle],
              kbDetailTitle: this.vulnTitle,
              page: this.currentPage,
              numberElements: this.itemsPerPage
            })
            const vulnerabilitiesData = (kbVulnerabilities || [])[0]?.vulnerabilities || { pageInfo: {}, vulnerabilities: [] }
            this.countVulnerabilities = vulnerabilitiesData?.pageInfo?.count || 0
            if ((vulnerabilitiesData?.vulnerabilities || []).length > 0) {
              const firstVulnerability = vulnerabilitiesData?.vulnerabilities[0]
              this.highestRiskRating = (kbVulnerabilities || [])[0]?.highestRiskRating
              this.title = firstVulnerability?.detail?.title
              this.description = firstVulnerability?.detail?.description
              this.recommendation = firstVulnerability?.detail?.recommendation
              for (const reference of (firstVulnerability?.detail?.references || [])) {
                this.references[reference.title] = reference.url
              }
            }
            for (const vuln of (vulnerabilitiesData?.vulnerabilities || [])) {
              this.vulnz.push({
                id: vuln?.id,
                content: vuln?.technicalDetail
              })
            }
            this.getVulnInfo = false
          } else {
            const newVulnz = await this.vulnerabilityService.getVulnerabilitiesWithoutInfo({
              scanner: SCANNER,
              scanId: parseInt(this.scanId as string),
              detailTitles: [this.vulnTitle],
              page: this.currentPage,
              numberElements: this.itemsPerPage
            })
            for (const vuln of newVulnz) {
              this.vulnz.push({
                id: vuln?.id,
                content: vuln?.technicalDetail
              })
            }
          }
          this.currentPage = this.currentPage + 1
        }
      } finally {
        this.loading = false
        release()
      }
    },
    /**
     * Fetch more data on scroll.
     */
    async handleScroll(): Promise<void> {
      if (this.vulnerabilityService.hasNext) {
        await this.getDataFromApi()
      }
    },
    /**
     * Refresh the vulnerability data.
     */
    async reloadData(): Promise<{ vulnz: Array<OxoVulnerabilityType>, riskRating?: Maybe<RiskRatingEnum> }> {
      this.vulnerabilityService = new VulnerabilityService(this.$axios)
      this.currentPage = 1
      this.vulnz = []
      this.getVulnInfo = true
      await this.getDataFromApi()
      return { vulnz: this.vulnz, riskRating: this.highestRiskRating }
    }
  }
})
</script>
